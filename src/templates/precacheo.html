<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pre-Cacheo ⚽</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background-color: #f7f9fc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .sidebar {
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            background-color: #fff;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            padding: 20px;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .main-content {
            margin-left: 250px;
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        /* Collapsed Sidebar */
        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .main-content.expanded {
            margin-left: 0;
        }

        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.mobile-active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }
        }

        .nav-link {
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .nav-link:hover,
        .nav-link.active {
            background-color: #e9ecef;
            color: #0d6efd;
        }

        .nav-link i {
            width: 25px;
        }

        /* Excel-like Table Styles */
        .excel-table {
            background: #fff;
            border: 1px solid #dee2e6;
            font-size: 0.85rem;
            width: 100%;
        }

        .excel-table th {
            background-color: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 8px;
            vertical-align: middle;
            font-weight: 600;
            color: #495057;
            text-align: center;
        }

        .excel-table td {
            padding: 6px 8px;
            vertical-align: middle;
            border: 1px solid #dee2e6;
        }

        .excel-table tbody tr:hover {
            background-color: #e8f0fe;
        }

        /* Filter Inputs in Header */
        .header-filter {
            width: 100%;
            padding: 4px;
            font-size: 0.8rem;
            border: 1px solid #ced4da;
            border-radius: 3px;
            margin-top: 5px;
        }

        /* Specific Column Styles */
        .col-ah {
            width: 80px;
            text-align: center;
            font-weight: 800;
            font-size: 1rem;
            background-color: #e8f5e9;
        }

        .col-res {
            width: 80px;
            text-align: center;
            font-weight: 800;
            font-size: 1rem;
        }

        .col-team {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .col-prev {
            font-size: 0.85rem;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .status-pending {
            color: #ffc107;
            font-weight: 600;
        }

        .status-scraped {
            color: #17a2b8;
            font-weight: 600;
        }

        /* H2H Col3 - Fondo rosa para distinguirla */
        .col-h2h-col3 {
            background-color: #ffe4ec !important;
        }

        /* Fondo rojo claro para celdas sin datos */
        .cell-no-data {
            background-color: #ffcdd2 !important;
        }
    </style>
</head>

<body>

    <!-- Sidebar -->
    <div class="sidebar">
        <h4 class="mb-4 text-primary"><i class="fa-solid fa-futbol me-2"></i>Analizador</h4>
        <nav class="nav flex-column">
            <a class="nav-link" href="/estudio"><i class="fa-solid fa-chart-line"></i> Estudio</a>
            <a class="nav-link" href="/explorador"><i class="fa-solid fa-compass"></i> Explorador</a>
            <a class="nav-link active" href="/precacheo"><i class="fa-solid fa-clock"></i> Pre-Cacheo</a>
            <a class="nav-link" href="/todos_resultados"><i class="fa-solid fa-list"></i> Resultados</a>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <div class="d-flex align-items-center gap-3">
                <button class="btn btn-outline-secondary btn-sm" id="sidebar-toggle" onclick="toggleSidebar()">
                    <i class="fa-solid fa-bars"></i>
                </button>
                <h4 class="mb-0"><i class="fa-solid fa-clock me-2"></i>Pre-Cacheo</h4>
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-primary btn-sm active" id="btn-proximos"
                        onclick="setViewMode('proximos')">
                        <i class="fa-solid fa-hourglass-start me-1"></i> Próximos
                    </button>
                    <button type="button" class="btn btn-outline-warning btn-sm" id="btn-pendientes"
                        onclick="setViewMode('pendientes')">
                        <i class="fa-solid fa-exclamation-triangle me-1"></i> Resultados Pendientes
                    </button>
                </div>
                <span class="badge bg-info" id="current-time-badge">Hora España: --:--</span>
                <div class="form-check ms-3">
                    <input class="form-check-input" type="checkbox" id="filter-only-with-history"
                        onchange="triggerSearch()">
                    <label class="form-check-label small" for="filter-only-with-history">
                        Solo con historial
                    </label>
                </div>
            </div>
            <div class="d-flex gap-2 align-items-center">
                <div id="scraping-status" class="d-none"></div>
                <button class="btn btn-success btn-sm" onclick="scrapeResultsPending()"
                    title="Scrapear solo resultados de partidos +2h sin score">
                    <i class="fa-solid fa-clock-rotate-left me-1"></i> Buscar Resultados (+2h)
                </button>
                <button class="btn btn-primary btn-sm" onclick="scrapeAllPending()">
                    <i class="fa-solid fa-cloud-download-alt me-1"></i> Scrapear Pendientes
                </button>
                <button class="btn btn-warning btn-sm" onclick="finalizeAllWithResults()">
                    <i class="fa-solid fa-check-double me-1"></i> Finalizar Todos
                </button>
                <button class="btn btn-primary btn-sm" onclick="triggerSearch()">
                    <i class="fa-solid fa-filter me-1"></i> Aplicar Filtros
                </button>
            </div>
        </div>

        <!-- Top Pagination Controls -->
        <nav aria-label="Page navigation" id="pagination-nav-top" class="d-none mb-2">
            <ul class="pagination pagination-sm justify-content-end mb-0" id="pagination-lista-top">
                <!-- Javascript populates this -->
            </ul>
        </nav>

        <div class="table-responsive">
            <table class="table table-bordered table-sm excel-table" id="results-table">
                <thead>
                    <tr>
                        <th style="width: 100px;">Fecha</th>
                        <th>Local</th>
                        <th>Visitante</th>
                        <th style="width: 80px;">
                            HA
                            <select class="header-filter" id="filter-handicap">
                                <option value="">Todos</option>
                                <option value="0.0">0.0</option>
                                <option value="0.5">0.5</option>
                                <option value="1.0">1.0</option>
                                <option value="1.5">1.5</option>
                                <option value="2.0">2.0</option>
                                <option value="2.5">2.5</option>
                                <option value="-0.5">-0.5</option>
                                <option value="-1.0">-1.0</option>
                                <option value="-1.5">-1.5</option>
                                <option value="-2.0">-2.0</option>
                                <option value="-2.5">-2.5</option>
                            </select>
                            <select class="header-filter mt-1" id="filter-ou" style="width: 100%;">
                                <option value="">O/U</option>
                                <option value="2.0">2.0</option>
                                <option value="2.5">2.5</option>
                                <option value="3.0">3.0</option>
                                <option value="3.5">3.5</option>
                                <option value="4.0">4+</option>
                            </select>
                        </th>
                        <th style="width: 80px;">FT</th>
                        <th>
                            Prev Home
                            <select class="header-filter mt-1" id="filter-prev-home-ah" style="width: 100%;">
                                <option value="">AH</option>
                                <option value="0.0">0.0</option>
                                <option value="0.5">0.5</option>
                                <option value="1.0">1.0</option>
                                <option value="1.5">1.5</option>
                                <option value="2.0">2.0</option>
                                <option value="-0.5">-0.5</option>
                                <option value="-1.0">-1.0</option>
                                <option value="-1.5">-1.5</option>
                                <option value="-2.0">-2.0</option>
                            </select>
                            <select class="header-filter mt-1" id="filter-prev-home-res" style="width: 100%;">
                                <option value="">Res...</option>
                                <option value="HOME_WIN">Win</option>
                                <option value="DRAW">Draw</option>
                                <option value="AWAY_WIN">Loss</option>
                            </select>
                        </th>
                        <th>
                            Prev Away
                            <select class="header-filter mt-1" id="filter-prev-away-ah" style="width: 100%;">
                                <option value="">AH</option>
                                <option value="0.0">0.0</option>
                                <option value="0.5">0.5</option>
                                <option value="1.0">1.0</option>
                                <option value="1.5">1.5</option>
                                <option value="2.0">2.0</option>
                                <option value="-0.5">-0.5</option>
                                <option value="-1.0">-1.0</option>
                                <option value="-1.5">-1.5</option>
                                <option value="-2.0">-2.0</option>
                            </select>
                            <select class="header-filter mt-1" id="filter-prev-away-res" style="width: 100%;">
                                <option value="">Res...</option>
                                <option value="HOME_WIN">Win</option>
                                <option value="DRAW">Draw</option>
                                <option value="AWAY_WIN">Loss</option>
                            </select>
                        </th>
                        <th style="width: 100px;">H2H Estadio</th>
                        <th style="width: 100px;">H2H General</th>
                        <th>H2H Col3</th>
                        <th>Ind. Local</th>
                        <th>Ind. Visitante</th>
                        <th style="width: 100px;">Acciones</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Results will be populated here -->
                </tbody>
            </table>
        </div>

        <!-- Pagination Controls -->
        <nav aria-label="Page navigation" id="pagination-nav" class="d-none mt-3">
            <ul class="pagination justify-content-center" id="pagination-lista">
                <!-- Javascript populates this -->
            </ul>
        </nav>


        <div id="loading-overlay" class="d-none">
            <div class="text-center">
                <div class="spinner-border text-primary" role="status"></div>
                <div id="loading-text" class="mt-2">Cargando...</div>
            </div>
        </div>
    </div>

    <script>
        let upcomingMatches = [];
        let precacheoData = {};
        let currentViewMode = 'proximos'; // 'proximos' o 'pendientes'

        // Pagination State
        let currentPage = 1;
        const itemsPerPage = 300; // User requested limit 300 (approx 200-300)
        let totalFilteredMatches = [];


        function showLoading(show, text = 'Cargando...') {
            document.getElementById('loading-overlay').classList.toggle('d-none', !show);
            document.getElementById('loading-text').textContent = text;
        }

        // Obtener hora actual de España
        function getSpainTime() {
            const now = new Date();
            // Convertir a hora de España
            const spainTime = new Date(now.toLocaleString('en-US', { timeZone: 'Europe/Madrid' }));
            return spainTime;
        }

        function updateCurrentTimeDisplay() {
            const spainTime = getSpainTime();
            const hours = spainTime.getHours().toString().padStart(2, '0');
            const minutes = spainTime.getMinutes().toString().padStart(2, '0');
            document.getElementById('current-time-badge').textContent = `Hora España: ${hours}:${minutes}`;
        }

        function setViewMode(mode) {
            currentViewMode = mode;

            // Actualizar botones
            document.getElementById('btn-proximos').classList.toggle('active', mode === 'proximos');
            document.getElementById('btn-pendientes').classList.toggle('active', mode === 'pendientes');

            // Recargar tabla
            triggerSearch();
        }

        // Parsear hora del partido (formato HH:MM)
        function parseMatchTime(timeStr) {
            if (!timeStr) return null;

            // El formato típico es "HH:MM" como "05:10", "06:00", etc.
            const match = timeStr.match(/(\d{1,2}):(\d{2})/);
            if (!match) return null;

            return {
                hours: parseInt(match[1]),
                minutes: parseInt(match[2])
            };
        }

        // Comparar si el partido es futuro respecto a la hora actual de España
        function isMatchUpcoming(match) {
            const spainTime = getSpainTime();

            // Prefer using full ISO start_time if available
            if (match.start_time) {
                const startTime = new Date(match.start_time);
                return startTime > spainTime;
            }

            // Fallback to simple time comparison (only works for same-day assumptions)
            // This was the buggy legacy behavior, but we keep it just in case
            const matchTimeStr = match.time;
            const matchTime = parseMatchTime(matchTimeStr);
            if (!matchTime) return true;

            const currentMinutes = spainTime.getHours() * 60 + spainTime.getMinutes();
            const matchMinutes = matchTime.hours * 60 + matchTime.minutes;

            return matchMinutes > currentMinutes;
        }

        // Comparar si el partido ya pasó (es candidato a resultado pendiente)
        function isMatchPast(match) {
            return !isMatchUpcoming(match);
        }

        async function triggerSearch() {
            const loadingText = currentViewMode === 'proximos'
                ? 'Cargando partidos próximos...'
                : 'Cargando resultados pendientes...';
            showLoading(true, loadingText);

            try {
                // Load upcoming matches from main page
                const res = await fetch('/api/matches?limit=1000');
                const data = await res.json();
                upcomingMatches = data.matches || [];

                // Load precacheo data
                const precRes = await fetch('/api/precacheo_list');
                const precData = await precRes.json();
                precacheoData = {};
                (precData.matches || []).forEach(m => {
                    precacheoData[m.match_id] = m;
                });

                // Filtrar por modo de vista PRIMERO
                let matchesToShow = upcomingMatches;

                if (currentViewMode === 'proximos') {
                    // Solo partidos con hora > hora actual España
                    matchesToShow = upcomingMatches.filter(m => {
                        return isMatchUpcoming(m);
                    });
                } else if (currentViewMode === 'pendientes') {
                    // Partidos ya pasados SIN resultado final
                    matchesToShow = upcomingMatches.filter(m => {
                        if (!isMatchPast(m)) return false; // Solo los pasados

                        // Verificar si tiene resultado final
                        const pc = precacheoData[m.id];
                        if (!pc) return true; // No scrapeado = pendiente

                        // Si tiene score válido, ya tiene resultado
                        const score = pc.score || pc.final_score || '';
                        if (score && score !== '??' && score !== '?:?' && score.includes(':')) {
                            // Verificar que no sea 0:0 con partido en progreso (sin finalizar)
                            return false; // Ya tiene resultado
                        }
                        return true; // Pendiente de resultado
                    });
                }

                // Apply additional filters
                // Apply additional filters
                const filteredMatches = applyFilters(matchesToShow);

                // Store globally for pagination
                totalFilteredMatches = filteredMatches;
                currentPage = 1; // Reset to page 1 on search

                renderTableWithPagination();
            } catch (err) {
                alert('Error: ' + err.message);
            }

            showLoading(false);
        }

        function renderTableWithPagination() {
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageItems = totalFilteredMatches.slice(start, end);

            renderTable(pageItems);
            renderPaginationControls();
        }

        function changePage(page) {
            if (page < 1 || page > Math.ceil(totalFilteredMatches.length / itemsPerPage)) return;
            currentPage = page;
            renderTableWithPagination();
            // Scroll to top of table
            document.querySelector('.table-responsive').scrollTop = 0;
        }

        function renderPaginationControls() {
            const nav = document.getElementById('pagination-nav');
            const lista = document.getElementById('pagination-lista');
            const totalPages = Math.ceil(totalFilteredMatches.length / itemsPerPage);

            if (totalPages <= 1) {
                nav.classList.add('d-none');
                return;
            }

            nav.classList.remove('d-none');
            lista.innerHTML = '';

            // Previous
            const prevLi = document.createElement('li');
            prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
            prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1}); return false;">Anterior</a>`;
            lista.appendChild(prevLi);

            // Pages
            // Simple logic: Show all if few, or range if many? 
            // Let's show: 1 ... current-1 current current+1 ... last
            // Or just simplified: Prev [Page X of Y] Next

            // "es decir de 200 i si se supera que pueda navegar por paginas"
            // Let's do simple Prev, Current, Next for now to avoid complexity with many pages

            const infoLi = document.createElement('li');
            infoLi.className = 'page-item disabled';
            infoLi.innerHTML = `<span class="page-link">Página ${currentPage} de ${totalPages} (${totalFilteredMatches.length} partidos)</span>`;
            lista.appendChild(infoLi);

            // Next
            const nextLi = document.createElement('li');
            nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
            nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1}); return false;">Siguiente</a>`;
            lista.appendChild(nextLi);
        }

        function getAsianResultCategory(teamGoals, oppGoals, ahLine) {
            if (teamGoals === null || oppGoals === null || ahLine === null || isNaN(ahLine)) return 'UNKNOWN';

            const diff = teamGoals - oppGoals;
            const line = parseFloat(ahLine);

            // Handle split lines (e.g. 0.25, 0.75) by calculating average result
            let lines = [];
            if (Math.abs(line % 0.5) === 0.25) {
                if (line > 0) {
                    lines = [line - 0.25, line + 0.25];
                } else {
                    lines = [line + 0.25, line - 0.25];
                }
            } else {
                lines = [line];
            }

            let results = [];
            for (let l of lines) {
                const val = diff + l;
                if (val > 0) results.push(1);
                else if (val < 0) results.push(-1);
                else results.push(0);
            }

            const avgRes = results.reduce((a, b) => a + b, 0) / results.length;

            if (avgRes > 0) return 'HOME_WIN'; // Cover
            if (avgRes < 0) return 'AWAY_WIN'; // No Cover
            return 'DRAW'; // Push
        }

        function calculateWDL(scoreStr, ahRaw, isHomePerspective) {
            if (!scoreStr || !ahRaw) return null;
            try {
                // Ensure format H:A
                const parts = scoreStr.replace('-', ':').split(':');
                if (parts.length !== 2) return null;
                const hg = parseInt(parts[0]);
                const ag = parseInt(parts[1]);

                let ah = parseFloat(ahRaw);
                if (isNaN(ah)) return null;

                // Adjust line for perspective
                // If isHomePerspective=True, we use AH as is (Home AH)
                // If isHomePerspective=False (Away Team), we treat them as Away.
                // Note: Standard Asian Result logic:
                // Home: asian_result(hg, ag, ah)
                // Away: asian_result(ag, hg, -ah)

                if (isHomePerspective) {
                    return getAsianResultCategory(hg, ag, ah);
                } else {
                    return getAsianResultCategory(ag, hg, -ah);
                }
            } catch (e) {
                console.error("Error calc WDL", e);
                return null;
            }
        }

        function normalizeBucket(ah) {
            if (ah === null || ah === undefined || ah === '') return null;
            const val = parseFloat(ah);
            if (isNaN(val)) return null;

            // If integer (close to), return integer
            if (Math.abs(val % 1) < 0.01) return val;

            const base = Math.floor(Math.abs(val));
            const sign = val >= 0 ? 1 : -1;
            // .25, .5, .75 -> .5
            return sign * (base + 0.5);
        }

        function applyFilters(matches) {
            // Team filters removed (inputs deleted)
            const teamHome = '';
            const teamAway = '';
            const handicap = document.getElementById('filter-handicap').value;
            const ouFilter = document.getElementById('filter-ou').value;
            const prevHomeAh = document.getElementById('filter-prev-home-ah').value;
            const prevAwayAh = document.getElementById('filter-prev-away-ah').value;

            // New Result Filters
            const prevHomeRes = document.getElementById('filter-prev-home-res').value;
            const prevAwayRes = document.getElementById('filter-prev-away-res').value;

            // Normalize buckets only once if filters exist
            const fBucketPrevHome = prevHomeAh ? normalizeBucket(prevHomeAh) : null;
            const fBucketPrevAway = prevAwayAh ? normalizeBucket(prevAwayAh) : null;

            // Console Debug
            if (prevHomeAh || prevAwayAh) {
                console.log("Filtering Debug:", {
                    prevHomeAh, fBucketPrevHome,
                    prevAwayAh, fBucketPrevAway
                });
            }

            return matches.filter(m => {
                // Filtro: Solo con historial (Prev Home y Prev Away deben tener datos)
                const onlyWithHistory = document.getElementById('filter-only-with-history').checked;
                if (onlyWithHistory) {
                    const pc = precacheoData[m.id];
                    if (!pc) return false;

                    // Verificar que tenga datos en Prev Home
                    const hasPrevHome = pc.last_home_match && pc.last_home_match.score;
                    // Verificar que tenga datos en Prev Away  
                    const hasPrevAway = pc.last_away_match && pc.last_away_match.score;

                    // Si alguno de los dos no tiene datos, filtrar
                    if (!hasPrevHome || !hasPrevAway) return false;
                }

                // Team filter
                if (teamHome && !(m.home_team || '').toLowerCase().includes(teamHome)) return false;
                if (teamAway && !(m.away_team || '').toLowerCase().includes(teamAway)) return false;

                // Handicap filter
                if (handicap) {
                    const mAh = parseFloat(m.handicap);
                    const fAh = parseFloat(handicap);
                    if (isNaN(mAh)) return false;

                    const absF = Math.abs(fAh);

                    // Logic for 2.5 bucket (range >= 2.25)
                    if (absF >= 2.49) {
                        if (fAh > 0) {
                            if (mAh < 2.24) return false;
                        } else {
                            if (mAh > -2.24) return false;
                        }
                    }
                    // Logic for 2.0 bucket (strict 2.0)
                    else if (absF >= 1.99 && absF <= 2.01) {
                        if (Math.abs(mAh - fAh) > 0.01) return false;
                    }
                    // Logic for .5 buckets (0.5, 1.5) => fuzzy range +/- 0.25
                    else if (Math.abs(absF % 1 - 0.5) < 0.01) {
                        if (Math.abs(mAh - fAh) > 0.26) return false;
                    }
                    // Default strict match
                    else {
                        if (Math.abs(mAh - fAh) > 0.01) return false;
                    }
                }

                // O/U (Goals Line) filter
                if (ouFilter) {
                    const pc = precacheoData[m.id];
                    if (!pc || !pc.main_match_odds || !pc.main_match_odds.goals_linea) return false;

                    const matchOU = parseFloat(pc.main_match_odds.goals_linea);
                    const filterOU = parseFloat(ouFilter);
                    if (isNaN(matchOU)) return false;

                    // Si el filtro es 4.0, coger 4 o superior
                    if (filterOU >= 4.0) {
                        if (matchOU < 4.0) return false;
                    } else {
                        // Para otros valores, fuzzy match (+/- 0.26)
                        if (Math.abs(matchOU - filterOU) > 0.26) return false;
                    }
                }

                // Prev Home Attributes
                if (prevHomeAh || prevHomeRes) {
                    const pc = precacheoData[m.id];
                    if (!pc || !pc.last_home_match) return false;

                    if (fBucketPrevHome !== null) {
                        const pAh = parseFloat(pc.last_home_match.handicap_line_raw);
                        const pBucket = normalizeBucket(pAh);

                        console.log(`Match ${m.home_team}: PrevHomeRaw=${pc.last_home_match.handicap_line_raw} pAh=${pAh} pBucket=${pBucket} Filter=${fBucketPrevHome}`);

                        if (pBucket === null) return false;

                        if (Math.abs(fBucketPrevHome) >= 2.5) {
                            if (fBucketPrevHome > 0) {
                                if (pBucket < 2.5) return false;
                            } else {
                                if (pBucket > -2.5) return false;
                            }
                        } else {
                            if (pBucket !== fBucketPrevHome) return false;
                        }
                    }

                    if (prevHomeRes) {
                        const wdl = calculateWDL(pc.last_home_match.score, pc.last_home_match.handicap_line_raw, true);
                        if (wdl !== prevHomeRes) return false;
                    }
                }

                // Prev Away Attributes
                if (prevAwayAh || prevAwayRes) {
                    const pc = precacheoData[m.id];
                    if (!pc || !pc.last_away_match) return false;

                    if (fBucketPrevAway !== null) {
                        const pAh = parseFloat(pc.last_away_match.handicap_line_raw);
                        const pBucket = normalizeBucket(pAh);

                        console.log(`Match ${m.away_team}: PrevAwayRaw=${pc.last_away_match.handicap_line_raw} pAh=${pAh} pBucket=${pBucket} Filter=${fBucketPrevAway}`);

                        if (pBucket === null) return false;

                        if (Math.abs(fBucketPrevAway) >= 2.5) {
                            if (fBucketPrevAway > 0) {
                                if (pBucket < 2.5) return false;
                            } else {
                                if (pBucket > -2.5) return false;
                            }
                        } else {
                            if (pBucket !== fBucketPrevAway) return false;
                        }
                    }

                    if (prevAwayRes) {
                        const wdl = calculateWDL(pc.last_away_match.score, pc.last_away_match.handicap_line_raw, false);
                        if (wdl !== prevAwayRes) return false;
                    }
                }

                return true;
            });
        }

        function renderTable(matches) {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            if (!matches || matches.length === 0) {
                tbody.innerHTML = `<tr><td colspan="11" class="text-center py-4">No hay partidos próximos</td></tr>`;
                return;
            }

            const formatAh = (val) => val !== null && val !== undefined ? val : '-';

            matches.forEach(m => {
                const tr = document.createElement('tr');
                const matchId = m.id;
                const home = m.home_team || '-';
                const away = m.away_team || '-';
                const ah = m.handicap || '-';

                // Format Date/Time
                let fechaDisplay = m.time || '-';
                if (m.start_time) {
                    const d = new Date(m.start_time);
                    const now = getSpainTime();

                    const isToday = d.getDate() === now.getDate() &&
                        d.getMonth() === now.getMonth() &&
                        d.getFullYear() === now.getFullYear();

                    const isTomorrow = new Date(now.getTime() + 86400000).getDate() === d.getDate() &&
                        d.getMonth() === new Date(now.getTime() + 86400000).getMonth();

                    const hours = d.getHours().toString().padStart(2, '0');
                    const minutes = d.getMinutes().toString().padStart(2, '0');

                    if (isToday) {
                        fechaDisplay = `${hours}:${minutes}`;
                    } else if (isTomorrow) {
                        fechaDisplay = `Mañana ${hours}:${minutes}`;
                    } else {
                        const day = d.getDate().toString().padStart(2, '0');
                        const month = (d.getMonth() + 1).toString().padStart(2, '0');
                        fechaDisplay = `${day}/${month} ${hours}:${minutes}`;
                    }
                }
                const fecha = fechaDisplay;

                // Check if scraped
                const pc = precacheoData[matchId];
                const isScraped = !!pc;

                // Check if has valid result (can be finalized)
                let hasValidResult = false;
                if (pc) {
                    const score = pc.score || pc.final_score || '';
                    hasValidResult = score && score !== '??' && score !== '?:?' && score.includes(':');
                }

                // FT (Score)
                let ftHtml = '<span class="text-muted">-</span>';
                if (pc && pc.score && pc.score !== '??') {
                    ftHtml = `<span class="fw-bold text-success">${pc.score}</span>`;
                } else if (pc && pc.final_score && pc.final_score !== '??') {
                    ftHtml = `<span class="fw-bold text-success">${pc.final_score}</span>`;
                } else {
                    ftHtml = '<span class="text-muted">?:?</span>';
                }

                // Prev Home
                let prevHomeHtml = '<span class="text-muted">-</span>';
                if (pc && pc.last_home_match && pc.last_home_match.score) {
                    const lhm = pc.last_home_match;
                    const ahVal = formatAh(lhm.handicap_line_raw);

                    // Calc WDL
                    const wdl = calculateWDL(lhm.score, lhm.handicap_line_raw, true);
                    const wdlClass = wdl === 'HOME_WIN' ? 'text-success' : (wdl === 'AWAY_WIN' ? 'text-danger' : 'text-dark');
                    // For Home Perspective: HOME_WIN = Green (Won vs AH), AWAY_WIN = Red (Lost vs AH)

                    // Rival Logic: Display the team that is NOT the current home team
                    // Usually lhm is Home Game for 'home', so rival is away_team.
                    let rivalName = lhm.away_team;
                    // Safety check if lhm.away_team IS the home team (e.g. they played away but it's recorded here?)
                    if (lhm.away_team && (lhm.away_team.includes(home) || home.includes(lhm.away_team))) {
                        rivalName = lhm.home_team;
                    }

                    prevHomeHtml = `
                        <div class="d-flex flex-column">
                            <div class="d-flex justify-content-between">
                                <span class="fw-bold small">${ahVal}</span>
                                <span class="fw-bold ${wdlClass}">${lhm.score}</span>
                            </div>
                            <div class="text-muted small text-truncate" style="max-width: 100px;" title="${rivalName}">${rivalName || ''}</div>
                        </div>
                    `;
                }

                // Prev Away
                let prevAwayHtml = '<span class="text-muted">-</span>';
                if (pc && pc.last_away_match && pc.last_away_match.score) {
                    const lam = pc.last_away_match;
                    const ahVal = formatAh(lam.handicap_line_raw);

                    // Calc WDL (perspective = false for away team)
                    const wdl = calculateWDL(lam.score, lam.handicap_line_raw, false);
                    // If calculateWDL return 'HOME_WIN', it means the "perspective team" (Away) WON the handicap
                    const wdlClass = wdl === 'HOME_WIN' ? 'text-success' : (wdl === 'AWAY_WIN' ? 'text-danger' : 'text-dark');

                    // Rival Logic: Display the team that is NOT the current away team
                    // Usually lam is Away Game for 'away', so rival is home_team.
                    let rivalName = lam.home_team;
                    if (lam.home_team && (lam.home_team.includes(away) || away.includes(lam.home_team))) {
                        rivalName = lam.away_team;
                    }

                    prevAwayHtml = `
                        <div class="d-flex flex-column">
                            <div class="d-flex justify-content-between">
                                <span class="fw-bold small">${ahVal}</span>
                                <span class="fw-bold ${wdlClass}">${lam.score}</span>
                            </div>
                            <div class="text-muted small text-truncate" style="max-width: 100px;" title="${rivalName}">${rivalName || ''}</div>
                        </div>
                    `;
                }

                // H2H Estadio (from market_analysis_data.stadium)
                let h2hStadiumHtml = '<span class="text-muted">-</span>';
                if (pc && pc.market_analysis_data && pc.market_analysis_data.stadium) {
                    const st = pc.market_analysis_data.stadium;
                    const movColor = st.is_covered === true ? 'text-success' : (st.is_covered === false ? 'text-danger' : 'text-dark');
                    h2hStadiumHtml = `
                        <div class="d-flex flex-column">
                            <div class="fw-bold small ${movColor}">${st.movement || '-'}</div>
                            ${st.result ? `<div class="small ${movColor}" style="font-size: 0.7rem;">${st.result}</div>` : ''}
                        </div>
                    `;
                }

                // H2H General (from market_analysis_data.general)
                let h2hGeneralHtml = '<span class="text-muted">-</span>';
                if (pc && pc.market_analysis_data && pc.market_analysis_data.general) {
                    const gen = pc.market_analysis_data.general;
                    const movColor = gen.is_covered === true ? 'text-success' : (gen.is_covered === false ? 'text-danger' : 'text-dark');
                    h2hGeneralHtml = `
                        <div class="d-flex flex-column">
                            <div class="fw-bold small ${movColor}">${gen.movement || '-'}</div>
                            ${gen.result ? `<div class="small ${movColor}" style="font-size: 0.7rem;">${gen.result}</div>` : ''}
                        </div>
                    `;
                }

                // H2H Col3 (from h2h_col3 object)
                let h2hCol3Html = '';
                if (pc && pc.h2h_col3 && pc.h2h_col3.status === 'found') {
                    const col3 = pc.h2h_col3;
                    // Verificar que no hay undefined en los datos
                    const handicap = (col3.handicap !== undefined && col3.handicap !== 'undefined') ? col3.handicap : null;
                    const golesHome = col3.goles_home;
                    const golesAway = col3.goles_away;
                    const homeTeam = (col3.h2h_home_team_name && col3.h2h_home_team_name !== 'undefined') ? col3.h2h_home_team_name : '';
                    const awayTeam = (col3.h2h_away_team_name && col3.h2h_away_team_name !== 'undefined') ? col3.h2h_away_team_name : '';

                    const score = (golesHome !== undefined && golesHome !== null &&
                        golesAway !== undefined && golesAway !== null)
                        ? `${golesHome}:${golesAway}` : null;

                    // Si tiene datos válidos, mostrar contenido
                    if (handicap || score) {
                        h2hCol3Html = `
                            <div class="d-flex flex-column">
                                <div class="d-flex justify-content-between">
                                    <span class="fw-bold small">${handicap || '-'}</span>
                                    <span class="fw-bold">${score || '-'}</span>
                                </div>
                                ${(homeTeam || awayTeam) ? `<div class="small text-muted" style="font-size: 0.75rem;">${homeTeam} vs ${awayTeam}</div>` : ''}
                            </div>
                        `;
                    }
                }

                // Ind. Comparisons - Helper para validar undefined
                const isValidValue = (val) => val !== undefined && val !== null && val !== 'undefined' && val !== '';

                let indLeftHtml = '';
                let indLeftHasData = false;
                if (pc && pc.comparativas_indirectas && pc.comparativas_indirectas.left) {
                    const l = pc.comparativas_indirectas.left;
                    const ahLine = isValidValue(l.ah_line) ? l.ah_line : (isValidValue(l.ah) ? l.ah : null);
                    const score = isValidValue(l.score) ? l.score : null;
                    const homeTeam = isValidValue(l.home_team) ? l.home_team : '';
                    const awayTeam = isValidValue(l.away_team) ? l.away_team : '';
                    const localia = isValidValue(l.localia) ? l.localia : '';

                    // Si tiene datos válidos, mostrar contenido
                    if (ahLine || score) {
                        indLeftHasData = true;
                        const cov = l.cover_status === 'CUBIERTO' ? 'text-success' : (l.cover_status === 'NO CUBIERTO' ? 'text-danger' : 'text-dark');
                        indLeftHtml = `
                            <div class="d-flex flex-column">
                                 <div class="d-flex justify-content-between">
                                    <span class="fw-bold small">${ahLine || '-'}</span>
                                    <span class="fw-bold ${cov}">${score || '-'}</span>
                                </div>
                                ${(homeTeam || awayTeam) ? `<div class="small text-muted" style="font-size: 0.75rem;">${homeTeam} vs ${awayTeam}</div>` : ''}
                                ${localia ? `<div class="small text-muted" style="font-size: 0.65rem;">Loc: ${localia}</div>` : ''}
                            </div>
                        `;
                    }
                }

                let indRightHtml = '';
                let indRightHasData = false;
                if (pc && pc.comparativas_indirectas && pc.comparativas_indirectas.right) {
                    const r = pc.comparativas_indirectas.right;
                    const ahLine = isValidValue(r.ah_line) ? r.ah_line : (isValidValue(r.ah) ? r.ah : null);
                    const score = isValidValue(r.score) ? r.score : null;
                    const homeTeam = isValidValue(r.home_team) ? r.home_team : '';
                    const awayTeam = isValidValue(r.away_team) ? r.away_team : '';
                    const localia = isValidValue(r.localia) ? r.localia : '';

                    // Si tiene datos válidos, mostrar contenido
                    if (ahLine || score) {
                        indRightHasData = true;
                        const cov = r.cover_status === 'CUBIERTO' ? 'text-success' : (r.cover_status === 'NO CUBIERTO' ? 'text-danger' : 'text-dark');
                        indRightHtml = `
                            <div class="d-flex flex-column">
                                 <div class="d-flex justify-content-between">
                                    <span class="fw-bold small">${ahLine || '-'}</span>
                                    <span class="fw-bold ${cov}">${score || '-'}</span>
                                </div>
                                ${(homeTeam || awayTeam) ? `<div class="small text-muted" style="font-size: 0.75rem;">${homeTeam} vs ${awayTeam}</div>` : ''}
                                ${localia ? `<div class="small text-muted" style="font-size: 0.65rem;">Loc: ${localia}</div>` : ''}
                            </div>
                        `;
                    }
                }

                // Determinar si H2H Col3 tiene datos
                let h2hCol3HasData = h2hCol3Html !== '';

                tr.innerHTML = `
                    <td class="text-center"><span class="badge bg-secondary">${fecha}</span></td>
                    <td class="col-team text-primary small" style="font-size: 0.8rem;">${home}</td>
                    <td class="col-team text-danger small" style="font-size: 0.8rem;">${away}</td>
                    <td class="col-ah">
                        ${formatAh(ah)}
                        ${pc && pc.main_match_odds && pc.main_match_odds.goals_linea ? `<div style="font-size: 0.6rem; color: #888; margin-top: -2px;">${pc.main_match_odds.goals_linea}</div>` : ''}
                    </td>
                    <td class="text-center col-res">${ftHtml}</td>
                    <td class="col-prev">${prevHomeHtml}</td>
                    <td class="col-prev">${prevAwayHtml}</td>
                    <td class="col-prev text-center">${h2hStadiumHtml}</td>
                    <td class="col-prev text-center">${h2hGeneralHtml}</td>
                    <td class="col-prev col-h2h-col3 text-center">${h2hCol3Html}</td>
                    <td class="col-prev ${!indLeftHasData ? 'cell-no-data' : ''}">${indLeftHtml}</td>
                    <td class="col-prev ${!indRightHasData ? 'cell-no-data' : ''}">${indRightHtml}</td>
                    <td class="text-center">
                        ${!isScraped
                        ? `<button class="btn btn-sm btn-primary" onclick="scrapeMatch('${matchId}')" title="Scrapear">
                                <i class="fas fa-download"></i>
                               </button>`
                        : `<button class="btn btn-sm btn-outline-info" onclick="scrapeMatch('${matchId}')" title="Re-scrapear">
                                <i class="fas fa-sync"></i>
                               </button>`
                    }
                        ${hasValidResult
                        ? `<button class="btn btn-sm btn-success" onclick="finalizeMatch('${matchId}')" title="Finalizar y mover al Explorador">
                                <i class="fas fa-check"></i>
                               </button>`
                        : ''}
                        <a href="/estudio/${matchId}" target="_blank" class="btn btn-sm btn-outline-secondary" title="Ver Estudio">
                            <i class="fas fa-eye"></i>
                        </a>
                        ${isScraped ? `<button class="btn btn-sm btn-outline-warning" onclick="searchPatterns('${matchId}', this)" title="Buscar Patrones Similares">
                            <i class="fas fa-search"></i>
                        </button>` : ''}
                    </td>
                `;
                tr.setAttribute('data-match-id', matchId);
                tbody.appendChild(tr);
            });
        }

        // Background scraping - doesn't block UI
        let scrapingInProgress = false;
        let scrapingQueue = [];
        let scrapingCurrent = 0;
        let scrapingTotal = 0;

        function updateScrapingStatus() {
            const statusDiv = document.getElementById('scraping-status');
            if (scrapingInProgress) {
                statusDiv.innerHTML = `<span class="badge bg-warning text-dark">
                    <i class="fas fa-spinner fa-spin me-1"></i>
                    Scrapeando ${scrapingCurrent}/${scrapingTotal}
                </span>`;
                statusDiv.classList.remove('d-none');
            } else {
                statusDiv.classList.add('d-none');
            }
        }

        function scrapeMatch(matchId) {
            // Fire and forget - don't await, don't block
            fetch('/api/precacheo_scrape', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ match_id: matchId })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.error) {
                        console.error('Error scraping:', data.error);
                    } else {
                        // Update just this row's status
                        precacheoData[matchId] = data.match;
                        // Refresh the table
                        const filteredMatches = applyFilters(upcomingMatches);
                        renderTable(filteredMatches);
                    }
                })
                .catch(err => console.error('Error scraping:', err));

            // Immediately change button to show it's being scraped
            const btn = document.querySelector(`button[onclick="scrapeMatch('${matchId}')"]`);
            if (btn) {
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                btn.disabled = true;
            }
        }

        // Buscar patrones similares en histórico
        async function searchPatterns(matchId, btnElement) {
            // Toggle: si ya existe la fila expandible, ocultarla
            const existingRow = document.getElementById(`patterns-row-${matchId}`);
            if (existingRow) {
                existingRow.remove();
                btnElement.classList.remove('active');
                return;
            }

            // Mostrar spinner
            const originalHtml = btnElement.innerHTML;
            btnElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            btnElement.disabled = true;

            try {
                const res = await fetch('/api/precacheo_pattern_search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ match_id: matchId })
                });
                const data = await res.json();

                btnElement.innerHTML = originalHtml;
                btnElement.disabled = false;

                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }

                // Crear fila expandible
                const matchRow = document.querySelector(`tr[data-match-id="${matchId}"]`);
                if (!matchRow) return;

                const expandRow = document.createElement('tr');
                expandRow.id = `patterns-row-${matchId}`;
                expandRow.className = 'patterns-expand-row';

                const info = data.match_info || {};
                const results = data.results || [];

                let resultsHtml = '';
                if (results.length === 0) {
                    resultsHtml = '<div class="text-muted text-center py-2">No se encontraron patrones similares</div>';
                } else {
                    const covered = results.filter(r => r.covered === 'COVER').length;
                    const notCovered = results.filter(r => r.covered === 'NO_COVER').length;

                    // Determinar filtro automático según comportamiento previo del favorito
                    const prevFavCovered = info.prev_fav_covered;
                    let autoFilter = 'all';
                    let autoFilterLabel = 'Todos';
                    if (prevFavCovered === true) {
                        autoFilter = 'cover';
                        autoFilterLabel = '✓ Favorito cubrió en su previo → Solo Cubiertos';
                    } else if (prevFavCovered === false) {
                        autoFilter = 'nocover';
                        autoFilterLabel = '✗ Favorito NO cubrió en su previo → Solo No Cubiertos';
                    }

                    resultsHtml = `
                        <div class="d-flex flex-column gap-2 mb-2">
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="small">
                                    <strong>Patrones:</strong> ${data.total_found} 
                                    | <strong>AH:</strong> ${info.ah_actual} 
                                    | <strong>Fav:</strong> ${info.favorito}
                                    ${info.prev_ah_favorito !== null ? `| <strong>Prev AH:</strong> ${info.prev_ah_favorito}` : ''}
                                    ${prevFavCovered !== null ? `| <strong class="${prevFavCovered ? 'text-success' : 'text-danger'}">Fav ${prevFavCovered ? 'CUBRIÓ' : 'NO CUBRIÓ'}</strong>` : ''}
                                </div>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-secondary btn-sm ${autoFilter === 'all' ? 'active' : ''}" onclick="filterPatterns('${matchId}', 'all')">Todos (${results.length})</button>
                                    <button class="btn btn-outline-success btn-sm ${autoFilter === 'cover' ? 'active' : ''}" onclick="filterPatterns('${matchId}', 'cover')">✓ Cubiertos (${covered})</button>
                                    <button class="btn btn-outline-danger btn-sm ${autoFilter === 'nocover' ? 'active' : ''}" onclick="filterPatterns('${matchId}', 'nocover')">✗ No Cubiertos (${notCovered})</button>
                                </div>
                            </div>
                            ${prevFavCovered !== null ? `<div class="alert alert-${prevFavCovered ? 'success' : 'danger'} py-1 px-2 mb-0 small">${autoFilterLabel}</div>` : ''}
                        </div>
                        <div class="table-responsive" style="max-height: 500px; overflow-y: auto;">
                        <table class="table table-sm table-bordered mb-0" style="font-size: 0.68rem;" id="patterns-table-${matchId}">
                            <thead class="table-light sticky-top">
                                <tr>
                                    <th>Fecha</th>
                                    <th>Local</th>
                                    <th>Visitante</th>
                                    <th>AH</th>
                                    <th>FT</th>
                                    <th>Cover</th>
                                    <th>Prev Home
                                        <div class="d-flex gap-1">
                                            <select class="form-select form-select-sm py-0" style="font-size:0.55rem;width:45px;" onchange="filterPatternsCol('${matchId}', 'prev-home-ah', this.value)">
                                                <option value="">AH</option>
                                                <option value="0.5">0.5</option>
                                                <option value="1">1</option>
                                                <option value="1.5">1.5</option>
                                                <option value="2">2+</option>
                                            </select>
                                            <select class="form-select form-select-sm py-0" style="font-size:0.55rem;width:35px;" onchange="filterPatternsCol('${matchId}', 'prev-home', this.value)">
                                                <option value="">Res</option>
                                                <option value="W">W</option>
                                                <option value="D">D</option>
                                                <option value="L">L</option>
                                            </select>
                                        </div>
                                    </th>
                                    <th>Prev Away
                                        <div class="d-flex gap-1">
                                            <select class="form-select form-select-sm py-0" style="font-size:0.55rem;width:45px;" onchange="filterPatternsCol('${matchId}', 'prev-away-ah', this.value)">
                                                <option value="">AH</option>
                                                <option value="0.5">0.5</option>
                                                <option value="1">1</option>
                                                <option value="1.5">1.5</option>
                                                <option value="2">2+</option>
                                            </select>
                                            <select class="form-select form-select-sm py-0" style="font-size:0.55rem;width:35px;" onchange="filterPatternsCol('${matchId}', 'prev-away', this.value)">
                                                <option value="">Res</option>
                                                <option value="W">W</option>
                                                <option value="D">D</option>
                                                <option value="L">L</option>
                                            </select>
                                        </div>
                                    </th>
                                    <th style="background:#e3f2fd;">H2H Estadio</th>
                                    <th style="background:#e3f2fd;">H2H General</th>
                                    <th style="background:#ffe4ec;">H2H Col3</th>
                                    <th style="background:#fff3e0;">Ind. Local</th>
                                    <th style="background:#fff3e0;">Ind. Visitante</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${results.map(r => {
                        const wdlClass = (wdl) => wdl === 'HOME_WIN' ? 'text-success' : (wdl === 'AWAY_WIN' ? 'text-danger' : 'text-dark');
                        const wdlLetter = (wdl) => wdl === 'HOME_WIN' ? 'W' : (wdl === 'AWAY_WIN' ? 'L' : 'D');

                        // Prev Home: AH + movement + score + rival
                        const prevHomeHtml = r.prev_home ?
                            `<div><span class="fw-bold">${r.prev_home.ah || '-'}</span> <span class="${wdlClass(r.prev_home.wdl)}">${r.prev_home.score || '-'}</span></div>${r.prev_home.movement ? `<div style="font-size:0.5rem;color:#666;">${r.prev_home.movement}</div>` : ''}<div class="text-muted" style="font-size:0.5rem;">${r.prev_home.rival || ''}</div>` :
                            '<span class="text-muted">-</span>';

                        // Prev Away: AH + movement + score + rival
                        const prevAwayHtml = r.prev_away ?
                            `<div><span class="fw-bold">${r.prev_away.ah || '-'}</span> <span class="${wdlClass(r.prev_away.wdl)}">${r.prev_away.score || '-'}</span></div>${r.prev_away.movement ? `<div style="font-size:0.5rem;color:#666;">${r.prev_away.movement}</div>` : ''}<div class="text-muted" style="font-size:0.5rem;">${r.prev_away.rival || ''}</div>` :
                            '<span class="text-muted">-</span>';

                        // H2H Estadio: movement + score
                        const h2hStadiumHtml = r.h2h_stadium ?
                            `<div class="fw-bold">${r.h2h_stadium.movement || '-'}</div><div class="${wdlClass(r.h2h_stadium.wdl)}">${r.h2h_stadium.score || '-'}</div>` :
                            '<span class="text-muted">-</span>';

                        // H2H General: movement + score
                        const h2hGeneralHtml = r.h2h_general ?
                            `<div class="fw-bold">${r.h2h_general.movement || '-'}</div><div class="${wdlClass(r.h2h_general.wdl)}">${r.h2h_general.score || '-'}</div>` :
                            '<span class="text-muted">-</span>';

                        // H2H Col3: ah + score + equipos
                        const h2hCol3Html = r.h2h_col3 ?
                            `<div><span class="fw-bold">${r.h2h_col3.ah || '-'}</span> ${r.h2h_col3.score || '-'}</div><div style="font-size:0.5rem;"><span class="text-primary">${r.h2h_col3.home_team || ''}</span> vs <span class="text-danger">${r.h2h_col3.away_team || ''}</span></div>` :
                            '<span class="text-muted">-</span>';

                        // Ind. Local
                        const indLocalHtml = r.ind_local ?
                            `<div><span class="fw-bold">${r.ind_local.ah || r.ind_local.handicap || '-'}</span> ${r.ind_local.score || r.ind_local.resultado || '-'}</div>` :
                            '<span class="text-muted">-</span>';

                        // Ind. Visitante
                        const indVisitanteHtml = r.ind_visitante ?
                            `<div><span class="fw-bold">${r.ind_visitante.ah || r.ind_visitante.handicap || '-'}</span> ${r.ind_visitante.score || r.ind_visitante.resultado || '-'}</div>` :
                            '<span class="text-muted">-</span>';

                        const prevHomeWdl = r.prev_home ? wdlLetter(r.prev_home.wdl) : '';
                        const prevAwayWdl = r.prev_away ? wdlLetter(r.prev_away.wdl) : '';
                        const prevHomeAh = r.prev_home && r.prev_home.ah != null ? Math.abs(parseFloat(r.prev_home.ah)) : '';
                        const prevAwayAh = r.prev_away && r.prev_away.ah != null ? Math.abs(parseFloat(r.prev_away.ah)) : '';

                        return `
                                    <tr data-cover="${r.covered}" data-prev-home="${prevHomeWdl}" data-prev-away="${prevAwayWdl}" data-prev-home-ah="${prevHomeAh}" data-prev-away-ah="${prevAwayAh}" ${autoFilter !== 'all' && ((autoFilter === 'cover' && r.covered !== 'COVER') || (autoFilter === 'nocover' && r.covered !== 'NO_COVER')) ? 'style="display:none;"' : ''}>
                                        <td><a href="/estudio?match_id=${r.match_id}" target="_blank" class="text-decoration-none" title="Abrir análisis">${r.date || '-'} 🔗</a></td>
                                        <td class="text-primary" style="font-size:0.65rem;">${r.home || '-'}</td>
                                        <td class="text-danger" style="font-size:0.65rem;">${r.away || '-'}</td>
                                        <td class="fw-bold text-center" style="background:#e8f5e9;">${r.ah || '-'}${r.ou ? `<div style="font-size:0.5rem;color:#888;">${r.ou}</div>` : ''}</td>
                                        <td class="fw-bold text-center">${r.score || '-'}</td>
                                        <td class="${r.covered === 'COVER' ? 'bg-success text-white' : (r.covered === 'NO_COVER' ? 'bg-danger text-white' : 'text-muted')} fw-bold text-center">
                                            ${r.covered === 'COVER' ? '✓' : (r.covered === 'NO_COVER' ? '✗' : '-')}
                                        </td>
                                        <td>${prevHomeHtml}</td>
                                        <td>${prevAwayHtml}</td>
                                        <td style="background:#e3f2fd;">${h2hStadiumHtml}</td>
                                        <td style="background:#e3f2fd;">${h2hGeneralHtml}</td>
                                        <td style="background:#ffe4ec;">${h2hCol3Html}</td>
                                        <td style="background:#fff3e0;">${indLocalHtml}</td>
                                        <td style="background:#fff3e0;">${indVisitanteHtml}</td>
                                    </tr>
                                `}).join('')}
                            </tbody>
                        </table>
                        </div>
                        <div class="d-flex justify-content-between mt-2 small">
                            <span class="text-muted">Mostrando ${results.length} de ${data.total_found}</span>
                            <span><strong class="text-success">✓ ${covered}</strong> cubiertos | <strong class="text-danger">✗ ${notCovered}</strong> no cubiertos | Ratio: <strong>${covered > 0 ? ((covered / (covered + notCovered)) * 100).toFixed(0) : 0}%</strong></span>
                        </div>
                    `;
                }

                expandRow.innerHTML = `
                    <td colspan="20" style="background: #f8f9fa; border-left: 3px solid #ffc107; padding: 10px;">
                        ${resultsHtml}
                    </td>
                `;

                // Insertar después de la fila del partido
                matchRow.insertAdjacentElement('afterend', expandRow);
                btnElement.classList.add('active');

            } catch (err) {
                btnElement.innerHTML = originalHtml;
                btnElement.disabled = false;
                alert('Error de red: ' + err.message);
            }
        }

        // Filtrar filas de la tabla de patrones por cover status
        function filterPatterns(matchId, filterType) {
            const table = document.getElementById(`patterns-table-${matchId}`);
            if (!table) return;

            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cover = row.getAttribute('data-cover');
                if (filterType === 'all') {
                    row.style.display = '';
                } else if (filterType === 'cover') {
                    row.style.display = cover === 'COVER' ? '' : 'none';
                } else if (filterType === 'nocover') {
                    row.style.display = cover === 'NO_COVER' ? '' : 'none';
                }
            });

            // Update button states
            const btnGroup = table.closest('td').querySelector('.btn-group');
            if (btnGroup) {
                btnGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                if (filterType === 'all') btnGroup.querySelector('.btn-outline-secondary').classList.add('active');
                else if (filterType === 'cover') btnGroup.querySelector('.btn-outline-success').classList.add('active');
                else if (filterType === 'nocover') btnGroup.querySelector('.btn-outline-danger').classList.add('active');
            }
        }

        // Filtrar filas por columna (Prev Home/Away W/D/L y AH)
        function filterPatternsCol(matchId, colName, filterValue) {
            const table = document.getElementById(`patterns-table-${matchId}`);
            if (!table) return;

            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                // Si hay filtro de cover activo, respetarlo
                const coverFilter = table.closest('td').querySelector('.btn-group .active');
                const activeCoverFilter = coverFilter ? coverFilter.textContent.includes('Cubiertos') ? (coverFilter.textContent.includes('No') ? 'nocover' : 'cover') : 'all' : 'all';

                let showByCover = true;
                if (activeCoverFilter === 'cover') showByCover = row.getAttribute('data-cover') === 'COVER';
                else if (activeCoverFilter === 'nocover') showByCover = row.getAttribute('data-cover') === 'NO_COVER';

                // Filtros de W/D/L
                const prevHomeWdl = row.getAttribute('data-prev-home');
                const prevAwayWdl = row.getAttribute('data-prev-away');

                // Filtros de AH
                const prevHomeAh = parseFloat(row.getAttribute('data-prev-home-ah')) || 0;
                const prevAwayAh = parseFloat(row.getAttribute('data-prev-away-ah')) || 0;

                // Obtener valores de todos los filtros activos
                const container = table.closest('td');
                const selects = container.querySelectorAll('select');
                let prevHomeWdlFilter = '', prevAwayWdlFilter = '', prevHomeAhFilter = '', prevAwayAhFilter = '';
                selects.forEach(sel => {
                    const onChange = sel.getAttribute('onchange') || '';
                    if (onChange.includes('prev-home-ah')) prevHomeAhFilter = sel.value;
                    else if (onChange.includes('prev-away-ah')) prevAwayAhFilter = sel.value;
                    else if (onChange.includes("prev-home'")) prevHomeWdlFilter = sel.value;
                    else if (onChange.includes("prev-away'")) prevAwayWdlFilter = sel.value;
                });

                // Función para comprobar rango de AH
                function matchesAhRange(ahVal, filterVal) {
                    if (!filterVal) return true;
                    const f = parseFloat(filterVal);
                    if (f === 0.5) return ahVal >= 0.25 && ahVal <= 0.75;
                    if (f === 1) return ahVal >= 0.75 && ahVal <= 1.25;
                    if (f === 1.5) return ahVal >= 1.25 && ahVal <= 1.75;
                    if (f === 2) return ahVal >= 1.75;
                    return true;
                }

                let showByCol = true;

                // Aplicar filtro actual
                if (colName === 'prev-home' && filterValue) {
                    showByCol = showByCol && prevHomeWdl === filterValue;
                } else if (colName === 'prev-away' && filterValue) {
                    showByCol = showByCol && prevAwayWdl === filterValue;
                } else if (colName === 'prev-home-ah' && filterValue) {
                    showByCol = showByCol && matchesAhRange(prevHomeAh, filterValue);
                } else if (colName === 'prev-away-ah' && filterValue) {
                    showByCol = showByCol && matchesAhRange(prevAwayAh, filterValue);
                }

                // También respetar otros filtros activos
                if (colName !== 'prev-home' && prevHomeWdlFilter) {
                    showByCol = showByCol && prevHomeWdl === prevHomeWdlFilter;
                }
                if (colName !== 'prev-away' && prevAwayWdlFilter) {
                    showByCol = showByCol && prevAwayWdl === prevAwayWdlFilter;
                }
                if (colName !== 'prev-home-ah' && prevHomeAhFilter) {
                    showByCol = showByCol && matchesAhRange(prevHomeAh, prevHomeAhFilter);
                }
                if (colName !== 'prev-away-ah' && prevAwayAhFilter) {
                    showByCol = showByCol && matchesAhRange(prevAwayAh, prevAwayAhFilter);
                }

                row.style.display = (showByCover && showByCol) ? '' : 'none';
            });
        }

        async function scrapeResultsPending() {
            if (!confirm('¿Buscar resultados finales de partidos que empezaron hace +2 horas?\nSe actualizarán los que encuentren resultado.')) return;

            try {
                const res = await fetch('/api/scrape_pending_results', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await res.json();

                if (data.status === 'success') {
                    alert(data.message + '\n\nRevisa la consola del servidor para ver el progreso.');
                    // Refrescar después de un delay
                    setTimeout(() => triggerSearch(), 5000);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (err) {
                alert('Error de red: ' + err.message);
            }
        }

        async function scrapeAllPending() {
            const handicap = document.getElementById('filter-handicap').value;
            // Note: Pre-Cacheo page filtering logic might not have goal line filter input, 
            // but if it does, we should capture it. 
            // Looking at the view_file, there is no explicit goal line filter INPUT in precacheo list header, 
            // only AH filter. So we pass handicap.

            if (!confirm(`¿Iniciar scrapeo de pendientes en segundo plano con filtro AH=${handicap || 'Todos'}?\nSe usarán 8 workers y se guardará el progreso.`)) return;

            try {
                const res = await fetch('/api/precacheo_scrape_background', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        handicap: handicap
                    })
                });
                const data = await res.json();

                if (data.status === 'success') {
                    alert(data.message);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (err) {
                alert('Error de red al iniciar scraping: ' + err.message);
            }
        }

        // Finalizar un partido individual (mover al Explorador)
        async function finalizeMatch(matchId) {
            const btn = document.querySelector(`button[onclick="finalizeMatch('${matchId}')"]`);
            if (btn) {
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                btn.disabled = true;
            }

            try {
                const res = await fetch(`/api/precacheo_finalize/${matchId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await res.json();

                if (data.status === 'success') {
                    // Eliminar de precacheoData local
                    delete precacheoData[matchId];
                    // Refrescar tabla
                    triggerSearch();
                } else {
                    alert('Error: ' + (data.error || 'No se pudo finalizar'));
                    if (btn) {
                        btn.innerHTML = '<i class="fas fa-check"></i>';
                        btn.disabled = false;
                    }
                }
            } catch (err) {
                console.error('Error finalizando:', err);
                alert('Error de red al finalizar: ' + err.message);
                if (btn) {
                    btn.innerHTML = '<i class="fas fa-check"></i>';
                    btn.disabled = false;
                }
            }
        }

        // Finalizar todos los partidos que tienen resultado
        // Finalizar todos los partidos que tienen resultado
        async function finalizeAllWithResults() {
            // Buscar todos los partidos con resultado válido
            const matchesWithResults = [];
            for (const [matchId, pc] of Object.entries(precacheoData)) {
                // Ensure robust check for score
                const score = pc.score || pc.final_score || '';
                if (score && score !== '??' && score !== '?:?' && score.includes(':')) {
                    matchesWithResults.push(matchId);
                }
            }

            if (matchesWithResults.length === 0) {
                alert('No hay partidos con resultado para finalizar.');
                return;
            }

            if (!confirm(`¿Finalizar ${matchesWithResults.length} partidos y moverlos al Explorador?`)) return;

            showLoading(true, `Finalizando ${matchesWithResults.length} partidos...`);

            try {
                // Batch Request
                const res = await fetch('/api/precacheo_finalize_batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ match_ids: matchesWithResults })
                });

                const data = await res.json();

                if (data.error) {
                    alert('Error: ' + data.error);
                } else {
                    const failures = data.failed_count || 0;
                    const success = data.success_count || 0;

                    if (failures > 0) {
                        alert(`Finalizados ${success}. Fallaron ${failures}. Revisa la consola para más detalles.`);
                        console.error("Batch failures:", data.errors);
                    } else {
                        // Success completely
                        // Optional: simpler alert or just refresh
                        // alert(`Proceso completado. ${success} partidos movidos.`);
                    }
                    // Refresh data
                    await triggerSearch();
                }
            } catch (err) {
                alert('Error de red: ' + err.message);
            } finally {
                showLoading(false);
            }
        }

        // Event listeners for filters
        document.querySelectorAll('.header-filter').forEach(input => {
            input.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    triggerSearch();
                }
            });
            input.addEventListener('change', function (e) {
                if (e.target.tagName === 'SELECT') {
                    triggerSearch();
                }
            });
        });

        // Sidebar Toggle Logic
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const mainContent = document.querySelector('.main-content');

            // Si es móvil (ancho menor a 768px, asumimos lógica móvil)
            if (window.innerWidth <= 768) {
                sidebar.classList.toggle('mobile-active');
            } else {
                sidebar.classList.toggle('collapsed');
                mainContent.classList.toggle('expanded');
            }
        }

        // Load on page load
        document.addEventListener('DOMContentLoaded', function () {
            updateCurrentTimeDisplay();
            // Actualizar hora cada minuto
            setInterval(updateCurrentTimeDisplay, 60000);
            triggerSearch();
        });
    </script>
</body>

</html>